        -:    0:Source:D:/Project_mp/testfinal/libModbus/ModbusPacketParse.c
        -:    0:Programs:14
        -:    1:#include "../libModbus/ModbusTcp.h"
        -:    2:unsigned int c2, d2, bytesrx;
        -:    3:unsigned char exceptioncode;
        -:    4:
        -:    5:uint16_t
       21:    6:modbusTcpParse(mbPacketParse_t *p_parseModbusTcpData, uint8_t *p_modbusRxBuf)
        -:    7:{
        -:    8:  // BYTE *ModbusTxBuf;
        -:    9:
       21:   10:  p_parseModbusTcpData->transactionID.v[1] = p_modbusRxBuf[0];
       21:   11:  p_parseModbusTcpData->transactionID.v[0] = p_modbusRxBuf[1];
        -:   12:
       21:   13:  p_parseModbusTcpData->protocolID.v[1] = p_modbusRxBuf[2];
       21:   14:  p_parseModbusTcpData->protocolID.v[0] = p_modbusRxBuf[3];
        -:   15:
       21:   16:  p_parseModbusTcpData->length = p_modbusRxBuf[5];
        -:   17:
       21:   18:  p_parseModbusTcpData->unitID = p_modbusRxBuf[6];
        -:   19:
       21:   20:  p_parseModbusTcpData->functionCode = p_modbusRxBuf[7];
        -:   21:
       21:   22:  p_parseModbusTcpData->startAddress.v[1] = p_modbusRxBuf[8];
       21:   23:  p_parseModbusTcpData->startAddress.v[0] = p_modbusRxBuf[9];
        -:   24:
       21:   25:  if (p_parseModbusTcpData->functionCode == PresetSingleRegister)
        -:   26:  {
        3:   27:    p_parseModbusTcpData->preset_Data.v[1] = p_modbusRxBuf[10];
        3:   28:    p_parseModbusTcpData->preset_Data.v[0] = p_modbusRxBuf[11];
        -:   29:  }
        -:   30:
       18:   31:  else if (p_parseModbusTcpData->functionCode == PresetMultipleRegisters)
        -:   32:  {
        -:   33:
        3:   34:    p_parseModbusTcpData->numberofRegister.v[1] = p_modbusRxBuf[10];
        3:   35:    p_parseModbusTcpData->numberofRegister.v[0] = p_modbusRxBuf[11];
        3:   36:    p_parseModbusTcpData->byteCount = p_modbusRxBuf[12];
        -:   37:
        9:   38:    for (c2 = 0; c2 < p_parseModbusTcpData->numberofRegister.Val; c2++)
        -:   39:    {
        6:   40:      d2 = c2 * 2;
        -:   41:
        6:   42:      p_parseModbusTcpData->data[c2].v[1] = p_modbusRxBuf[13 + d2];
        6:   43:      p_parseModbusTcpData->data[c2].v[0] = p_modbusRxBuf[14 + d2];
        -:   44:    }
        -:   45:  }
        -:   46:
       15:   47:  else if (p_parseModbusTcpData->functionCode == ForceSingleCoil)
        -:   48:  {
        3:   49:    p_parseModbusTcpData->forceData[0].v[1] = p_modbusRxBuf[10];
        3:   50:    p_parseModbusTcpData->forceData[0].v[0] = p_modbusRxBuf[11];
        -:   51:  }
        -:   52:
       12:   53:  else if (p_parseModbusTcpData->functionCode == ForceMultipleCoils) // force multiple coils
        -:   54:  {
        3:   55:    p_parseModbusTcpData->byteCount = p_modbusRxBuf[12];
        9:   56:    for (c2 = 0; c2 < p_parseModbusTcpData->byteCount / 2; c2++)
        -:   57:    {
        -:   58:
        6:   59:      p_parseModbusTcpData->coilData[c2] = (p_modbusRxBuf[14 + c2 * 2] << 8) | p_modbusRxBuf[13 + c2 * 2];
        -:   60:      // printf("%04x \n",parse->Coil_data[c2]);
        -:   61:    }
        -:   62:  }
        -:   63:
        -:   64:  else
        -:   65:  {
        9:   66:    p_parseModbusTcpData->numberofRegister.v[1] = p_modbusRxBuf[10];
        9:   67:    p_parseModbusTcpData->numberofRegister.v[0] = p_modbusRxBuf[11];
        -:   68:  }
        -:   69:
        -:   70:  //    bytesrx = 0x6 + parseModbusTcpData->Length;
       21:   71:  return 0;
        -:   72:}
