        -:    0:Source:Z:/ModbusTcpRenamed8Fn/libModbus/readcoilstatus.c
        -:    0:Programs:14
        -:    1:#include"../libModbus/ModbusTcp.h"
        -:    2://#define bitcheck(byte,nbit) ((byte) &   (1<<(nbit)))
        -:    3:#define SET(x,y)  x |= (1 << y) 
        -:    4:#define READ(x,y)  ((0u == (x & (1<<y)))?0u:1u)
        -:    5:
        -:    6: unsigned int NoOfBits, Regbit, reg, RegbitTx, regTx, byte_index, bit_count, wordOffset;
        -:    7: uint16_t Txtempbuf[100];
        -:    8: unsigned int byte_count, h, bit_index, limit, coil_bit;
        -:    9: unsigned int TempReg;
        -:   10:
        -:   11://unsigned char byteValue;
        -:   12:
        -:   13:/* Basic bit manipulation macros
        -:   14:   No one should ever have to rewrite these
        -:   15:
        -:   16://Set bit y (0-indexed) of x to '1' by generating a a mask with a '1' in the proper bit location and ORing x with the mask.
        -:   17:
        -:   18:#define SET(x,y) x |= (1 << y)
        -:   19:
        -:   20://Set bit y (0-indexed) of x to '0' by generating a mask with a '0' in the y position and 1's elsewhere then ANDing the mask with x.
        -:   21:
        -:   22:#define CLEAR(x,y) x &= ~(1<< y)
        -:   23:
        -:   24://Return '1' if the bit value at position y within x is '1' and '0' if it's 0 by ANDing x with a bit mask where the bit in y's position is '1' and '0' elsewhere and comparing it to all 0's.  Returns '1' in least significant bit position if the value of the bit is '1', '0' if it was '0'.
        -:   25:
        -:   26:#define READ(x,y) ((0u == (x & (1<<y)))?0u:1u)
        -:   27:
        -:   28://Toggle bit y (0-index) of x to the inverse: '0' becomes '1', '1' becomes '0' by XORing x with a bitmask where the bit in position y is '1' and all others are '0'.
        -:   29:
        -:   30:#define TOGGLE(x,y) (x ^= (1<<y))
        -:   31:
        -:   32: */
        -:   33:
        -:   34:uint16_t
        1:   35:readCoilStatus(uint8_t *p_modbusTxBuf, uint16_t *p_dataMemory, mbPacketParse_t *p_parseModbusTcpData) {
        -:   36:
        -:   37:
        -:   38:
        -:   39:
        -:   40:    // uint16_t dummy[100];
        -:   41:
        1:   42:    p_modbusTxBuf[0] = p_parseModbusTcpData->transactionID.v[1];
        1:   43:    p_modbusTxBuf[1] = p_parseModbusTcpData->transactionID.v[0];
        -:   44:
        1:   45:    p_modbusTxBuf[2] = p_parseModbusTcpData->protocolID.v[1];
        1:   46:    p_modbusTxBuf[3] = p_parseModbusTcpData->protocolID.v[0];
        -:   47:
        1:   48:    p_modbusTxBuf[4] = 0X0;
        -:   49:
        1:   50:    p_modbusTxBuf[6] = p_parseModbusTcpData->unitID;
        1:   51:    p_modbusTxBuf[7] = p_parseModbusTcpData->functionCode;
        -:   52:
        1:   53:    byte_count = (p_parseModbusTcpData->numberofRegister.Val / 0x8) + 1;
        1:   54:    p_modbusTxBuf[8] = byte_count;
        -:   55:    //byte_index = 9;
        1:   56:    p_modbusTxBuf[5] = 0x03 + byte_count;
        -:   57:
        1:   58:    NoOfBits = p_parseModbusTcpData->numberofRegister.Val;
        -:   59:
        -:   60:
       10:   61:    for (bit_count = 0; bit_count < NoOfBits; bit_count++) // byte count 
        -:   62:    {
        9:   63:        Regbit = (p_parseModbusTcpData->startAddress.Val + bit_count - 1) % 16; // 20 - 1 % 16 = 4th bit
        9:   64:        reg = (p_parseModbusTcpData->startAddress.Val + bit_count - 1) / 16; // 20 - 1 /16 = 1st  reg
        9:   65:        RegbitTx = (bit_count) % 16; // 20 - 1 % 16 = 4th bit -- bit increment
        9:   66:        regTx = (bit_count) / 16; // 20 - 1 /16 = 1st  reg -- register increment
        -:   67:
        -:   68:
        9:   69:        coil_bit = READ(p_dataMemory[reg], Regbit);
        9:   70:        Txtempbuf[regTx] |= coil_bit << RegbitTx;
        -:   71:
        -:   72:
        -:   73:    }
        -:   74:
        2:   75:    for (byte_index = 0; byte_index < (regTx + 1); byte_index++) {
        -:   76:        //4times
        1:   77:        wordOffset = byte_index * 2;
        1:   78:        p_modbusTxBuf[9 + wordOffset] = (Txtempbuf[byte_index] % 0x100);
        1:   79:        p_modbusTxBuf[10 + wordOffset] = (Txtempbuf[byte_index] / 0x100);
        -:   80:    }
        -:   81:
        1:   82:    limit = p_modbusTxBuf[5] + 0x6;
        1:   83:    return limit;
        -:   84:}
        -:   85:
