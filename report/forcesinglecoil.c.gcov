        -:    0:Source:Z:/ModbusTcpRenamed8Fn/libModbus/forcesinglecoil.c
        -:    0:Programs:14
        -:    1:#include "ModbusTcp.h"
        -:    2:#define SET(x, y) x |= (1 << y)
        -:    3:#define READ(x, y) ((0u == (x & (1 << y))) ? 0u : 1u)
        -:    4:#define CLEAR(x, y) x &= ~(1 << y)
        -:    5:
        -:    6:/* Force Single Coil - Function Code - 05
        -:    7: *  The query message specifies the coil reference to be forced
        -:    8: * A value of FF 00 hex requests the coil to be ON.
        -:    9: * A value of 00 00 requests it to be OFF.
        -:   10: *  All other values are illegal and will not affect the coil.
        -:   11: *
        -:   12: * QUERY FRAME:
        -:   13:| Transaction Identifier | Protocol Identifier | Length | Unit Identifier | Function Code | Coil Address |   Force Data Value     |
        -:   14:|------------------------|---------------------|--------|-----------------|---------------|--------------|------------------------|
        -:   15:|       2 bytes          |      2 bytes        |2 bytes |      1 byte     |     1 byte    |    2 bytes   |           2 bytes      |
        -:   16:
        -:   17:RESPONSE FRAME:
        -:   18:| Transaction Identifier | Protocol Identifier | Length | Unit Identifier | Function Code | Coil Address |     Force Data Value   |
        -:   19:|------------------------|---------------------|--------|-----------------|---------------|--------------|------------------------|
        -:   20:|       2 bytes          |      2 bytes        |2 bytes |      1 byte     |     1 byte    |    2 bytes   |         2 bytes        |
        -:   21: *
        -:   22: * INPUT FRAME    = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x10, 0x05, 0x00, 0xAC, 0xFF, 0x00}
        -:   23: * RESPONSE FRAME = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x10, 0x05, 0x00, 0xAC, 0xFF, 0x00}
        -:   24: */
        -:   25:
        2:   26:uint16_t forceSingleCoil(uint8_t *p_modbusTxBuf, uint16_t *p_dataMemory, mbPacketParse_t *p_parseModbusTcpData)
        -:   27:{
        -:   28:    unsigned int length, Regbit, reg;
        -:   29:
        2:   30:    p_modbusTxBuf[0] = p_parseModbusTcpData->transactionID.v[1];
        2:   31:    p_modbusTxBuf[1] = p_parseModbusTcpData->transactionID.v[0];
        -:   32:
        2:   33:    p_modbusTxBuf[2] = p_parseModbusTcpData->protocolID.v[1];
        2:   34:    p_modbusTxBuf[3] = p_parseModbusTcpData->protocolID.v[0];
        -:   35:
        2:   36:    p_modbusTxBuf[4] = 0X0;
        2:   37:    p_modbusTxBuf[5] = p_parseModbusTcpData->length;
        -:   38:    // Output[5] = 0X3 + Output[8];
        2:   39:    p_modbusTxBuf[6] = p_parseModbusTcpData->unitID;
        2:   40:    p_modbusTxBuf[7] = p_parseModbusTcpData->functionCode;
        -:   41:
        2:   42:    p_modbusTxBuf[8] = p_parseModbusTcpData->startAddress.v[1]; // coil address Hi
        2:   43:    p_modbusTxBuf[9] = p_parseModbusTcpData->startAddress.v[0]; // coil address Lo
        -:   44:
        2:   45:    p_modbusTxBuf[10] = p_parseModbusTcpData->forceData[0].v[1]; // Force data Hi (FF/00)
        2:   46:    p_modbusTxBuf[11] = p_parseModbusTcpData->forceData[0].v[0]; // Force data Lo (00)
        -:   47:
        2:   48:    Regbit = (p_parseModbusTcpData->startAddress.Val - 1) % 16; // 20 - 1 % 16 = 4th bit
        2:   49:    reg = (p_parseModbusTcpData->startAddress.Val - 1) / 16;    // 20 - 1 /16 = 1st  reg
        -:   50:
        2:   51:    if ((p_parseModbusTcpData->forceData[0].Val == 0xff00) || (p_parseModbusTcpData->forceData[0].Val == 0x0000))
        -:   52:    {
        2:   53:        if (p_parseModbusTcpData->forceData[0].Val == 0xFF00)
        -:   54:        {
        1:   55:            SET(p_dataMemory[reg], Regbit);
        -:   56:        }
        -:   57:        else
        -:   58:        {
    #####:   59:            CLEAR(p_dataMemory[reg], Regbit);
        -:   60:        }
        -:   61:    }
        -:   62:    else
        -:   63:    {
        1:   64:        p_parseModbusTcpData->functionCode = p_parseModbusTcpData->functionCode + 0x80;
        1:   65:        modbusError(p_parseModbusTcpData, p_modbusTxBuf, Illegal_Data_Value);
        -:   66:    }
        -:   67:    //  p_dataMemory.Addr = p_parseModbusTcpData->StartAddress.v[0];
        -:   68:    //  p_dataMemory.Val = p_parseModbusTcpData->NumberofRegister.v[1];
        -:   69:   
        2:   70:    length = 0x6 + p_modbusTxBuf[5];
        2:   71:    return length;
        -:   72:}
