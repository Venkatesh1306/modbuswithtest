        -:    0:Source:Z:/ModbusTcpRenamed8Fn/libModbus/ModbusFrame.c
        -:    0:Programs:14
        -:    1:#include "../libModbus/ModbusTcp.h"
        -:    2:mbPacketParse_t p_parseModbusTcpData;
        -:    3://WORD frameLength;
        -:    4:
        -:    5:uint16_t
       21:    6:modbusTcpFrame (uint8_t *p_modbusRxBuf, uint16_t *p_dataMemory, uint8_t *p_modbusTxBuf,uint16_t modBusframeLength)
        -:    7:{
        -:    8:
        -:    9:
       21:   10:  modbusTcpParse (&p_parseModbusTcpData, p_modbusRxBuf);
        -:   11:
       44:   12:  if (!(p_parseModbusTcpData.functionCode == ReadCoilStatus ||
       36:   13:        p_parseModbusTcpData.functionCode == ReadInputStatus ||
       32:   14:        p_parseModbusTcpData.functionCode == ReadHoldingRegister ||
       28:   15:        p_parseModbusTcpData.functionCode == ReadInputRegisters ||
       23:   16:        p_parseModbusTcpData.functionCode == ForceSingleCoil ||
       17:   17:        p_parseModbusTcpData.functionCode == PresetSingleRegister ||
        7:   18:        p_parseModbusTcpData.functionCode == ForceMultipleCoils ||
        4:   19:        p_parseModbusTcpData.functionCode == PresetMultipleRegisters
        -:   20:        ))
        -:   21:    {
        1:   22:      p_parseModbusTcpData.functionCode = p_parseModbusTcpData.functionCode + 0x80;
        1:   23:      modbusError (&p_parseModbusTcpData, p_modbusTxBuf, Illegal_Function_Code);
        1:   24:       modBusframeLength = 0x9;
        -:   25:    }
       20:   26:  else if(p_parseModbusTcpData.numberofRegister.Val>(MaxSizeTcpTx-8))
        -:   27:    {
    #####:   28:      p_parseModbusTcpData.functionCode = p_parseModbusTcpData.functionCode + 0x80;
    #####:   29:      modbusError (&p_parseModbusTcpData, p_modbusTxBuf, Illegal_Data_Value );
    #####:   30:      modBusframeLength = 0x9;
        -:   31:    }
        -:   32:  else if
       38:   33:    (p_parseModbusTcpData.functionCode == ReadInputStatus ||
       34:   34:     p_parseModbusTcpData.functionCode == ReadHoldingRegister ||
       30:   35:     p_parseModbusTcpData.functionCode == ReadInputRegisters ||
       14:   36:     p_parseModbusTcpData.functionCode == PresetMultipleRegisters)
        -:   37:    {
       23:   38:      if ((p_parseModbusTcpData.startAddress.Val > (int) (DataRegistersize)) ||
        5:   39:          ((p_parseModbusTcpData.startAddress.Val + p_parseModbusTcpData.numberofRegister.Val) > (int) (DataRegistersize)))
        -:   40:        {
        4:   41:          p_parseModbusTcpData.functionCode = p_parseModbusTcpData.functionCode + 0x80;
        4:   42:          modbusError (&p_parseModbusTcpData, p_modbusTxBuf, Illegal_Data_Address);
        4:   43:          modBusframeLength = 0x9;
        -:   44:        }
        -:   45:    }
       20:   46:    else if (p_parseModbusTcpData.functionCode == ReadCoilStatus ||
       18:   47:           p_parseModbusTcpData.functionCode == ReadInputStatus ||
        9:   48:           p_parseModbusTcpData.functionCode == ForceMultipleCoils)
        -:   49:  {
       13:   50:      if ((p_parseModbusTcpData.startAddress.Val > (int) (DataRegister1size)) ||
        3:   51:          ((p_parseModbusTcpData.startAddress.Val + p_parseModbusTcpData.numberofRegister.Val) > (int) (DataRegister1size)))
        -:   52:    {
        2:   53:        p_parseModbusTcpData.functionCode = p_parseModbusTcpData.functionCode + 0x80;
        2:   54:          modbusError (&p_parseModbusTcpData, p_modbusTxBuf, Illegal_Data_Address);
        2:   55:          modBusframeLength = 0x9;
        -:   56:    }
        -:   57:  }
        -:   58:  else if
        6:   59:    (p_parseModbusTcpData.functionCode == ForceSingleCoil)
        -:   60:    {
        3:   61:      if (p_parseModbusTcpData.startAddress.Val  > (int) (DataRegister1size))
        -:   62:        {
        -:   63:          
        1:   64:        p_parseModbusTcpData.functionCode = p_parseModbusTcpData.functionCode + 0x80;
        1:   65:          modbusError (&p_parseModbusTcpData, p_modbusTxBuf, Illegal_Data_Address);
        1:   66:          modBusframeLength = 0x9;
        -:   67:        }
        -:   68:    }
        -:   69:  else if
        3:   70:    (p_parseModbusTcpData.functionCode == PresetSingleRegister)
        -:   71:    {
        3:   72:      if (p_parseModbusTcpData.startAddress.Val > (int) (DataRegistersize))
        -:   73:        {
        1:   74:          p_parseModbusTcpData.functionCode = p_parseModbusTcpData.functionCode + 0x80;
        1:   75:          modbusError (&p_parseModbusTcpData, p_modbusTxBuf, Illegal_Data_Address);
        1:   76:          modBusframeLength = 0x9;
        -:   77:        }
        -:   78:    }
        -:   79:
        -:   80:
        -:   81: 
        -:   82:
       21:   83:  if (p_parseModbusTcpData.functionCode == ReadHoldingRegister)
        -:   84:    {
        1:   85:      modBusframeLength = readHoldingRegisters(p_modbusTxBuf, p_dataMemory, &p_parseModbusTcpData);
        -:   86:    }
       21:   87:  if (p_parseModbusTcpData.functionCode == PresetSingleRegister)
        -:   88:    {
        2:   89:      modBusframeLength  = presetSingleRegister(p_modbusTxBuf, p_dataMemory, &p_parseModbusTcpData);
        -:   90:    }
       21:   91:  if (p_parseModbusTcpData.functionCode == PresetMultipleRegisters)
        -:   92:    {
        2:   93:      modBusframeLength = presetMultipleRegisters(p_modbusTxBuf,p_dataMemory, &p_parseModbusTcpData);
        -:   94:    }
        -:   95:
        -:   96:    
       21:   97:    if (p_parseModbusTcpData.functionCode == ReadInputStatus)
        -:   98:    {
        1:   99:      modBusframeLength = readInputStatus(p_modbusTxBuf, p_dataMemory, &p_parseModbusTcpData);
        -:  100:    }
       21:  101:    if (p_parseModbusTcpData.functionCode == ReadCoilStatus)
        -:  102:    {
        1:  103:      modBusframeLength = readCoilStatus(p_modbusTxBuf, p_dataMemory, &p_parseModbusTcpData);
        -:  104:    }
       21:  105:     if (p_parseModbusTcpData.functionCode == ReadInputRegisters)
        -:  106:    {
        1:  107:      modBusframeLength = readInputReg(p_modbusTxBuf, p_dataMemory, &p_parseModbusTcpData);
        -:  108:    }
       21:  109:     if (p_parseModbusTcpData.functionCode == ForceMultipleCoils)
        -:  110:    {
        2:  111:      modBusframeLength = forceMultipleCoils(p_modbusTxBuf, p_dataMemory, &p_parseModbusTcpData);
        -:  112:    }
       21:  113:    if (p_parseModbusTcpData.functionCode == ForceSingleCoil)
        -:  114:    {
        2:  115:      modBusframeLength = forceSingleCoil(p_modbusTxBuf, p_dataMemory, &p_parseModbusTcpData);
        -:  116:    }
       21:  117:  return modBusframeLength;
        -:  118:}
        -:  119:
        -:  120:
        -:  121:
