        -:    0:Source:D:/Project_mp/testfinal/Modbus1/forcesinglecoil.c
        -:    0:Programs:14
        -:    1:#include "testingdata.h"
        -:    2:#define SET(x,y)  x |= (1 << y) 
        -:    3:#define READ(x,y)  ((0u == (x & (1<<y)))?0u:1u)
        -:    4:#define CLEAR(x,y) x &= ~(1<< y)
        -:    5:
        -:    6:/* Force Single Coil - Function Code - 05
        -:    7: *  The query message specifies the coil reference to be forced
        -:    8: * A value of FF 00 hex requests the coil to be ON. 
        -:    9: * A value of 00 00 requests it to be OFF.
        -:   10: *  All other values are illegal and will not affect the coil.
        -:   11: * 
        -:   12: * QUERY FRAME:
        -:   13:| Transaction Identifier | Protocol Identifier | Length | Unit Identifier | Function Code | Coil Address |   Force Data Value     |
        -:   14:|------------------------|---------------------|--------|-----------------|---------------|--------------|------------------------|
        -:   15:|       2 bytes          |      2 bytes        |2 bytes |      1 byte     |     1 byte    |    2 bytes   |           2 bytes      |
        -:   16:
        -:   17:RESPONSE FRAME:
        -:   18:| Transaction Identifier | Protocol Identifier | Length | Unit Identifier | Function Code | Coil Address |     Force Data Value   |
        -:   19:|------------------------|---------------------|--------|-----------------|---------------|--------------|------------------------|
        -:   20:|       2 bytes          |      2 bytes        |2 bytes |      1 byte     |     1 byte    |    2 bytes   |         2 bytes        |
        -:   21: *
        -:   22: * INPUT FRAME    = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x10, 0x05, 0x00, 0xAC, 0xFF, 0x00}
        -:   23: * RESPONSE FRAME = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x10, 0x05, 0x00, 0xAC, 0xFF, 0x00}
        -:   24: */
        -:   25:
    #####:   26:WORD forcesinglecoil(BYTE *ModbusTcpTxBuf, unsigned short int*COIL, parse1 *parse) {
        -:   27:    unsigned int length, Regbit, reg;
        -:   28:
    #####:   29:    ModbusTcpTxBuf[0] = parse->TransactionID.v[1];
    #####:   30:    ModbusTcpTxBuf[1] = parse->TransactionID.v[0];
        -:   31:
    #####:   32:    ModbusTcpTxBuf[2] = parse->ProtocolID.v[1];
    #####:   33:    ModbusTcpTxBuf[3] = parse->ProtocolID.v[0];
        -:   34:
    #####:   35:    ModbusTcpTxBuf[4] = 0X0;
    #####:   36:    ModbusTcpTxBuf[5] = parse->Length;
        -:   37:    // Output[5] = 0X3 + Output[8];
    #####:   38:    ModbusTcpTxBuf[6] = parse->UnitID;
    #####:   39:    ModbusTcpTxBuf[7] = parse->FunctionCode;
        -:   40:
    #####:   41:    ModbusTcpTxBuf[8] = parse->StartAddress.v[1]; // coil address Hi
    #####:   42:    ModbusTcpTxBuf[9] = parse->StartAddress.v[0]; //coil address Lo
        -:   43:
    #####:   44:    ModbusTcpTxBuf[10] = parse->ForceData[0].v[1]; //Force data Hi (FF/00)
    #####:   45:    ModbusTcpTxBuf[11] = parse->ForceData[0].v[0]; //Force data Lo (00))
        -:   46:
    #####:   47:    Regbit = (parse->StartAddress.Val - 1) % 16; // 20 - 1 % 16 = 4th bit
    #####:   48:    reg = (parse->StartAddress.Val - 1) / 16; // 20 - 1 /16 = 1st  reg
    #####:   49:   if (parse->ForceData[0].Val == 0xFF00) {
    #####:   50:       SET(COIL[reg], Regbit);
        -:   51:   } else {
    #####:   52:       CLEAR(COIL[reg], Regbit);
        -:   53:   }
        -:   54:    //  COIL.Addr = parse->StartAddress.v[0];
        -:   55:    //  COIL.Val = parse->NumberofRegister.v[1];
        -:   56:
    #####:   57:    length = 0x6 + ModbusTcpTxBuf[5];
    #####:   58:    return length;
        -:   59:
        -:   60:}
