        -:    0:Source:D:/Project_mp/testfinal/Modbus1/presetmultipleregisters.c
        -:    0:Programs:14
        -:    1:#include "testingdata.h"
        -:    2:/*QUERY FRAME:
        -:    3:
        -:    4:| Transaction Identifier | Protocol Identifier | Length | Unit Identifier | Function Code | Starting Address | Quantity of Registers | Byte Count | Data (2 bytes per register) |
        -:    5:|------------------------|---------------------|--------|-----------------|---------------|------------------|-----------------------|------------|-----------------------------|
        -:    6:|       2 bytes          |      2 bytes        |2 bytes |      1 byte     |     1 byte    |     2 bytes      |       2 bytes         |   1 byte   |         n bytes            |
        -:    7:
        -:    8:
        -:    9:RESPONSE FRAME:
        -:   10:
        -:   11:| Transaction Identifier | Protocol Identifier | Length | Unit Identifier | Function Code | Starting Address | Quantity of Registers |
        -:   12:|------------------------|---------------------|--------|-----------------|---------------|------------------|-----------------------|
        -:   13:|       2 bytes          |      2 bytes        |2 bytes |      1 byte     |     1 byte    |     2 bytes      |       2 bytes         |
        -:   14:
        -:   15: * Function Code - 16 (10 HEX)
        -:   16: * DataRegister[25]={0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x0009, 0x0008, 0x0007, 0x0007, 0x0006, 0x0005, 0x0004, 0x0003, 0x0002, 0x0001, 0x0025, 0x0035, 0x0036, 0x9957, 0x7890};
        -:   17: * INPUT FRAME = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x10, 0x10, 0x00, 0x01, 0x00, 0x02, 0x04, 0x00, 0x0A, 0x01, 0x02}
        -:   18: * 
        -:   19: * After Processing the Query the DataRegister changes if no error is detected i.e to preset two registers starting at 01 to 0x0000A, 0x0102  
        -:   20: * RESPONSE FRAME = {0x0, 0x1, 0x2, 0x3, 0x0, 0x12, 0x10, 0x10, 0x0, 0x1, 0x0, 0x2} - 12 bytes.
        -:   21: * DATAREGISTER = {0x0000, 0x000A, 0x0102, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x0009, 0x0008, 0x0007, 0x0007, 0x0006, 0x0005, 0x0004, 0x0003, 0x0002, 0x0001, 0x0025, 0x0035, 0x0036, 0x9957, 0x7890 }
        -:   22:
        -:   23: * If error detected
        -:   24: * RESPONSE FRAME = {0x0, 0x1, 0x2, 0x3, 0x0, 0x9, 0x10, 0x90, 0x3} - last byte refers to exception code
        -:   25: * DATAREGISTER UNMODIFIED.
        -:   26:
        -:   27: */
        -:   28:
        -:   29:
        -:   30:
    #####:   31:WORD presetmultipleregisters(BYTE *ModbusTcpTxBuf, WORD *DataRegister, parse1 *parse) {
        -:   32:    unsigned int limit, limit1, data1, data2, DATA, check;
        -:   33:
    #####:   34:    ModbusTcpTxBuf[0] = parse->TransactionID.v[1];
    #####:   35:    ModbusTcpTxBuf[1] = parse->TransactionID.v[0];
        -:   36:
    #####:   37:    ModbusTcpTxBuf[2] = parse->ProtocolID.v[1];
    #####:   38:    ModbusTcpTxBuf[3] = parse->ProtocolID.v[0];
        -:   39:
    #####:   40:    ModbusTcpTxBuf[4] = 0X0;
        -:   41:
        -:   42:    // Output[5] = 0X3 + Output[8];
    #####:   43:    ModbusTcpTxBuf[6] = parse->UnitID;
        -:   44:
    #####:   45:    ModbusTcpTxBuf[7] = parse->FunctionCode;
        -:   46:
        -:   47:
        -:   48:
    #####:   49:    for (limit = 0; limit < parse->NumberofRegister.v[0]; limit++) {
        -:   50:        //data1 = parse->ForceData[limit].v[0];
        -:   51:        //data2 = parse->ForceData[limit].v[1]*0x100;
        -:   52:        //DATA = data1 + data2;
    #####:   53:        if ( parse->ForceData[limit].Val >= 65000) {
        -:   54:
    #####:   55:            parse->FunctionCode = parse->FunctionCode + 128;
    #####:   56:            modbuserror(parse, ModbusTcpTxBuf, Illegal_Data_Value);
    #####:   57:            limit = parse->NumberofRegister.v[0] + 1;
    #####:   58:            ModbusTcpTxBuf[5] = 0X3;
    #####:   59:            check = 1;
        -:   60:        } else {
        -:   61:
    #####:   62:            DataRegister[parse->StartAddress.Val + limit] = parse->ForceData[limit].v[0]+(parse->ForceData[limit].v[1]*0x100);
        -:   63:
        -:   64:
        -:   65:        }
        -:   66:
        -:   67:        //limit1 = limit * 2;
        -:   68:
        -:   69:        //DataRegister[parse->StartAddress.Val + limit1] = parse->ForceData.v[0 + limit];
        -:   70:    }
    #####:   71:    if (check!= 1) {
    #####:   72:        ModbusTcpTxBuf[8] = parse->StartAddress.v[1];
    #####:   73:        ModbusTcpTxBuf[9] = parse->StartAddress.v[0];
    #####:   74:        ModbusTcpTxBuf[10] = parse->NumberofRegister.v[1];
    #####:   75:        ModbusTcpTxBuf[11] = parse->NumberofRegister.v[0];
    #####:   76:        ModbusTcpTxBuf[5] = 0X06;
        -:   77:    }
        -:   78:
        -:   79:
        -:   80:    // DataRegister[parse->StartAddress.Val] = (parse->NumberofRegister.v[0] + parse->NumberofRegister.v[1]*0x100);
        -:   81:
    #####:   82:    return ModbusTcpTxBuf[5] + 0x06;
        -:   83:}
