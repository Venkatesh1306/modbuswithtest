        -:    0:Source:D:/Project_mp/testfinal/Modbus1/presetmultipleregisters.c
        -:    0:Programs:14
        -:    1:#include "testingdata.h"
        -:    2:/*QUERY FRAME:
        -:    3:
        -:    4:| Transaction Identifier | Protocol Identifier | Length | Unit Identifier | Function Code | Starting Address | Quantity of Registers | Byte Count | Data (2 bytes per register) |
        -:    5:|------------------------|---------------------|--------|-----------------|---------------|------------------|-----------------------|------------|-----------------------------|
        -:    6:|       2 bytes          |      2 bytes        |2 bytes |      1 byte     |     1 byte    |     2 bytes      |       2 bytes         |   1 byte   |         n bytes            |
        -:    7:
        -:    8:
        -:    9:RESPONSE FRAME:
        -:   10:
        -:   11:| Transaction Identifier | Protocol Identifier | Length | Unit Identifier | Function Code | Starting Address | Quantity of Registers |
        -:   12:|------------------------|---------------------|--------|-----------------|---------------|------------------|-----------------------|
        -:   13:|       2 bytes          |      2 bytes        |2 bytes |      1 byte     |     1 byte    |     2 bytes      |       2 bytes         |
        -:   14:
        -:   15: * Function Code - 16 (10 HEX)
        -:   16: * DataRegister[25]={0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x0009, 0x0008, 0x0007, 0x0007, 0x0006, 0x0005, 0x0004, 0x0003, 0x0002, 0x0001, 0x0025, 0x0035, 0x0036, 0x9957, 0x7890};
        -:   17: * INPUT FRAME = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x10, 0x10, 0x00, 0x01, 0x00, 0x02, 0x04, 0x00, 0x0A, 0x01, 0x02}
        -:   18: *
        -:   19: * After Processing the Query the DataRegister changes if no error is detected i.e to preset two registers starting at 01 to 0x0000A, 0x0102
        -:   20: * RESPONSE FRAME = {0x0, 0x1, 0x2, 0x3, 0x0, 0x12, 0x10, 0x10, 0x0, 0x1, 0x0, 0x2} - 12 bytes.
        -:   21: * DATAREGISTER = {0x0000, 0x000A, 0x0102, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x0009, 0x0008, 0x0007, 0x0007, 0x0006, 0x0005, 0x0004, 0x0003, 0x0002, 0x0001, 0x0025, 0x0035, 0x0036, 0x9957, 0x7890 }
        -:   22:
        -:   23: * If error detected
        -:   24: * RESPONSE FRAME = {0x0, 0x1, 0x2, 0x3, 0x0, 0x9, 0x10, 0x90, 0x3} - last byte refers to exception code
        -:   25: * DATAREGISTER UNMODIFIED.
        -:   26:
        -:   27: */
        -:   28:
        2:   29:WORD presetmultipleregisters(BYTE *ModbusTcpTxBuf, WORD *DataRegister, parse1 *parse)
        -:   30:{
        -:   31:    unsigned int limit, limit1, data1, data2, DATA, check;
        -:   32:
        2:   33:    ModbusTcpTxBuf[0] = parse->TransactionID.v[1];
        2:   34:    ModbusTcpTxBuf[1] = parse->TransactionID.v[0];
        -:   35:
        2:   36:    ModbusTcpTxBuf[2] = parse->ProtocolID.v[1];
        2:   37:    ModbusTcpTxBuf[3] = parse->ProtocolID.v[0];
        -:   38:
        2:   39:    ModbusTcpTxBuf[4] = 0X0;
        -:   40:
        -:   41:    // Output[5] = 0X3 + Output[8];
        2:   42:    ModbusTcpTxBuf[6] = parse->UnitID;
        -:   43:
        2:   44:    ModbusTcpTxBuf[7] = parse->FunctionCode;
        -:   45:
        5:   46:    for (limit = 0; limit < parse->NumberofRegister.v[0]; limit++)
        -:   47:    {
        -:   48:        // data1 = parse->ForceData[limit].v[0];
        -:   49:        // data2 = parse->ForceData[limit].v[1]*0x100;
        -:   50:        // DATA = data1 + data2;
        3:   51:        if (parse->ForceData[limit].Val >= 65000)
        -:   52:        {
        -:   53:
        1:   54:            parse->FunctionCode = parse->FunctionCode + 128;
        1:   55:            modbuserror(parse, ModbusTcpTxBuf, Illegal_Data_Value);
        1:   56:            limit = parse->NumberofRegister.v[0] + 1;
        1:   57:            ModbusTcpTxBuf[5] = 0X3;
        1:   58:            check = 1;
        -:   59:        }
        -:   60:        else
        -:   61:        {
        -:   62:
        2:   63:            DataRegister[parse->StartAddress.Val + limit] = parse->ForceData[limit].v[0] + (parse->ForceData[limit].v[1] * 0x100);
        -:   64:        }
        -:   65:
        -:   66:        // limit1 = limit * 2;
        -:   67:
        -:   68:        // DataRegister[parse->StartAddress.Val + limit1] = parse->ForceData.v[0 + limit];
        -:   69:    }
        2:   70:    if (check != 1)
        -:   71:    {
        1:   72:        ModbusTcpTxBuf[8] = parse->StartAddress.v[1];
        1:   73:        ModbusTcpTxBuf[9] = parse->StartAddress.v[0];
        1:   74:        ModbusTcpTxBuf[10] = parse->NumberofRegister.v[1];
        1:   75:        ModbusTcpTxBuf[11] = parse->NumberofRegister.v[0];
        1:   76:        ModbusTcpTxBuf[5] = 0X06;
        -:   77:    }
        -:   78:
        -:   79:    // DataRegister[parse->StartAddress.Val] = (parse->NumberofRegister.v[0] + parse->NumberofRegister.v[1]*0x100);
        -:   80:
        2:   81:    return ModbusTcpTxBuf[5] + 0x06;
        -:   82:}
