        -:    0:Source:D:/Project_mp/testfinal/Modbus1/forcemultiplecoils.c
        -:    0:Programs:14
        -:    1:#include "testingdata.h"
        -:    2:
        -:    3:
        -:    4:#define SET(x,y)  x |= (1 << y) 
        -:    5:#define READ(x,y)  ((0u == (x & (1<<y)))?0u:1u)
        -:    6:#define CLEAR(x,y) x &= ~(1<< y)
        -:    7:
        -:    8:
        -:    9:// coil address -> reg and bit ->
        -:   10:
        -:   11:WORD
        1:   12:forcemultiplecoils (BYTE *ModbusTcpTxBuf, unsigned short int  *COIL , parse1 *parse)
        -:   13:{
        -:   14:    unsigned int NoOfBits,bit_count ,Regbit, regTx, RegbitTx, reg;
        -:   15:    //unsigned int coil_byte_index,coil_byte_count, coil_byte_count,coil_byteValue,coil_bit_index,coil_register_index, coil_register_status,coil_data;
        -:   16:    unsigned int coil_data;
        1:   17:  ModbusTcpTxBuf[0] = parse->TransactionID.v[1];
        1:   18:  ModbusTcpTxBuf[1] = parse->TransactionID.v[0];
        -:   19:
        1:   20:  ModbusTcpTxBuf[2] = parse->ProtocolID.v[1];
        1:   21:  ModbusTcpTxBuf[3] = parse->ProtocolID.v[0];
        -:   22:
        1:   23:  ModbusTcpTxBuf[4] = 0X0;
        1:   24:  ModbusTcpTxBuf[5] = 0x06;
        -:   25:
        1:   26:  ModbusTcpTxBuf[6] = parse->UnitID;
        1:   27:  ModbusTcpTxBuf[7] = parse->FunctionCode;
        -:   28:
        1:   29:  ModbusTcpTxBuf[8] = parse->StartAddress.v[1];
        1:   30:  ModbusTcpTxBuf[9] = parse->StartAddress.v[0];
        -:   31:
        1:   32:  ModbusTcpTxBuf[10] = parse->NumberofRegister.v[1];
        1:   33:  ModbusTcpTxBuf[11] = parse->NumberofRegister.v[0];
        -:   34:  
        1:   35:  NoOfBits = parse->NumberofRegister.Val; // Quantity of coils
        -:   36:  
       21:   37:     for (bit_count = NoOfBits-1; bit_count >= 0; bit_count--) // byte count 
        -:   38:    {
       41:   39:        Regbit = (parse->StartAddress.Val + bit_count - 1) % 16; // 20 - 1 % 16 = 4th bit
       21:   40:        reg = (parse->StartAddress.Val + bit_count - 1) / 16; // 20 - 1 /16 = 1st  reg
        -:   41:       
       21:   42:        RegbitTx = (bit_count) % 16; // 20 - 1 % 16 = 4th bit -- bit increment
       21:   43:        regTx = (bit_count) / 16; // 20 - 1 /16 = 1st  reg -- register increment
        -:   44:        
       21:   45:        coil_data = READ(parse->Coil_data[regTx],RegbitTx);
        -:   46:        
       21:   47:        if(coil_data == 0x1)
        -:   48:        {
        8:   49:            SET(COIL[reg],Regbit);
        -:   50:        }
        -:   51:        else
        -:   52:        {
       13:   53:            CLEAR(COIL[reg],Regbit);
        -:   54:        }
       21:   55:        if(bit_count == 0)
        -:   56:        {
        1:   57:            break;
        -:   58:        }
        -:   59:     }   
        1:   60:  return 0x12;
        -:   61:        
        -:   62:}
