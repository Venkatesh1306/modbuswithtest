        -:    0:Source:D:/Project_mp/testfinal/Modbus1/forcemultiplecoils.c
        -:    0:Programs:14
        -:    1:#include "testingdata.h"
        -:    2:
        -:    3:#define SET(x, y) x |= (1 << y)
        -:    4:#define READ(x, y) ((0u == (x & (1 << y))) ? 0u : 1u)
        -:    5:#define CLEAR(x, y) x &= ~(1 << y)
        -:    6:
        -:    7:// coil address -> reg and bit ->
        -:    8:
        2:    9:WORD forcemultiplecoils(BYTE *ModbusTcpTxBuf, unsigned short int *COIL, parse1 *parse)
        -:   10:{
        -:   11:    unsigned int NoOfBits, bit_count, Regbit, regTx, RegbitTx, reg;
        -:   12:    // unsigned int coil_byte_index,coil_byte_count, coil_byte_count,coil_byteValue,coil_bit_index,coil_register_index, coil_register_status,coil_data;
        -:   13:    unsigned int coil_data;
        2:   14:    ModbusTcpTxBuf[0] = parse->TransactionID.v[1];
        2:   15:    ModbusTcpTxBuf[1] = parse->TransactionID.v[0];
        -:   16:
        2:   17:    ModbusTcpTxBuf[2] = parse->ProtocolID.v[1];
        2:   18:    ModbusTcpTxBuf[3] = parse->ProtocolID.v[0];
        -:   19:
        2:   20:    ModbusTcpTxBuf[4] = 0X0;
        2:   21:    ModbusTcpTxBuf[5] = 0x06;
        -:   22:
        2:   23:    ModbusTcpTxBuf[6] = parse->UnitID;
        2:   24:    ModbusTcpTxBuf[7] = parse->FunctionCode;
        -:   25:
        2:   26:    ModbusTcpTxBuf[8] = parse->StartAddress.v[1];
        2:   27:    ModbusTcpTxBuf[9] = parse->StartAddress.v[0];
        -:   28:
        2:   29:    ModbusTcpTxBuf[10] = parse->NumberofRegister.v[1];
        2:   30:    ModbusTcpTxBuf[11] = parse->NumberofRegister.v[0];
        -:   31:
        2:   32:    NoOfBits = parse->NumberofRegister.Val; // Quantity of coils
        -:   33:
       27:   34:    for (bit_count = NoOfBits - 1; bit_count >= 0; bit_count--) // byte count
        -:   35:    {
       52:   36:        Regbit = (parse->StartAddress.Val + bit_count - 1) % 16; // 20 - 1 % 16 = 4th bit
       27:   37:        reg = (parse->StartAddress.Val + bit_count - 1) / 16;    // 20 - 1 /16 = 1st  reg
        -:   38:
       27:   39:        RegbitTx = (bit_count) % 16; // 20 - 1 % 16 = 4th bit -- bit increment
       27:   40:        regTx = (bit_count) / 16;    // 20 - 1 /16 = 1st  reg -- register increment
        -:   41:
       27:   42:        if (parse->Coil_data[regTx] > 65000)
        -:   43:        {
        1:   44:            parse->FunctionCode = parse->FunctionCode + 0x80;
        1:   45:            modbuserror(parse, ModbusTcpTxBuf, Illegal_Data_Value);
        1:   46:            break;
        -:   47:        }
        -:   48:        else
        -:   49:        {
       26:   50:            coil_data = READ(parse->Coil_data[regTx], RegbitTx);
        -:   51:
       26:   52:            if (coil_data == 0x1)
        -:   53:            {
       10:   54:                SET(COIL[reg], Regbit);
        -:   55:            }
        -:   56:            else
        -:   57:            {
       16:   58:                CLEAR(COIL[reg], Regbit);
        -:   59:            }
       26:   60:            if (bit_count == 0)
        -:   61:            {
        1:   62:                break;
        -:   63:            }
        -:   64:        }
        -:   65:    }
        2:   66:    return 0x12;
        -:   67:}
