        -:    0:Source:D:/Project_mp/testfinal/Modbus1/forcemultiplecoils.c
        -:    0:Programs:14
        -:    1:#include "testingdata.h"
        -:    2:#define SET(x,y)  x |= (1 << y) 
        -:    3:#define READ(x,y)  ((0u == (x & (1<<y)))?0u:1u)
        -:    4:#define CLEAR(x,y) x &= ~(1<< y)
        -:    5:
        -:    6:
        -:    7:// coil address -> reg and bit ->
        -:    8:unsigned int coil_byte_index,coil_byte_count, coil_byte_count,coil_byteValue,coil_bit_index,coil_register_index, coil_register_status,coil_data;
        -:    9:WORD
        2:   10:forcemultiplecoils (BYTE *ModbusTcpTxBuf, unsigned char  *COIL , parse1 *parse)
        -:   11:{
        -:   12:    unsigned int NoOfBits,bit_count ,Regbit, regTx, RegbitTx, reg;
        -:   13:    
        2:   14:  ModbusTcpTxBuf[0] = parse->TransactionID.v[1];
        2:   15:  ModbusTcpTxBuf[1] = parse->TransactionID.v[0];
        -:   16:
        2:   17:  ModbusTcpTxBuf[2] = parse->ProtocolID.v[1];
        2:   18:  ModbusTcpTxBuf[3] = parse->ProtocolID.v[0];
        -:   19:
        2:   20:  ModbusTcpTxBuf[4] = 0X0;
        2:   21:  ModbusTcpTxBuf[5] = parse->Length;
        -:   22:  // Output[5] = 0X3 + Output[8];
        2:   23:  ModbusTcpTxBuf[6] = parse->UnitID;
        2:   24:  ModbusTcpTxBuf[7] = parse->FunctionCode;
        -:   25:
        2:   26:  ModbusTcpTxBuf[8] = parse->StartAddress.v[1];
        2:   27:  ModbusTcpTxBuf[9] = parse->StartAddress.v[0];
        -:   28:
        2:   29:  ModbusTcpTxBuf[10] = parse->NumberofRegister.v[1];
        2:   30:  ModbusTcpTxBuf[11] = parse->NumberofRegister.v[0];
        -:   31:  
        2:   32:  NoOfBits = parse->NumberofRegister.Val; // Quantity of coils
        -:   33:  
       24:   34:     for (bit_count = NoOfBits+1; bit_count >= 0; bit_count--) // byte count 
        -:   35:    {
       46:   36:        Regbit = (parse->StartAddress.Val + bit_count - 1) % 16; // 20 - 1 % 16 = 4th bit
       24:   37:        reg = (parse->StartAddress.Val + bit_count - 1) / 16; // 20 - 1 /16 = 1st  reg
        -:   38:       
       24:   39:        RegbitTx = (bit_count) % 8; // 20 - 1 % 16 = 4th bit -- bit increment
       24:   40:        regTx = (bit_count) / 8; // 20 - 1 /16 = 1st  reg -- register increment
        -:   41:        
        -:   42:        
        -:   43:       // if(Regbit == 0 ){}
        -:   44:        // Txtempbuf[regTx] |= READ(COIL[reg], Regbit) << RegbitTx;
        -:   45:        
       24:   46:        coil_data = READ(parse->Coil_data[regTx],RegbitTx);
        -:   47:        
       24:   48:        if(coil_data == 0x1)
        -:   49:        {
       12:   50:            SET(COIL[reg],Regbit);
        -:   51:        }
        -:   52:        else
        -:   53:        {
       12:   54:            CLEAR(COIL[reg],Regbit);
        -:   55:        }
       24:   56:        if(bit_count == 0)
        -:   57:        {
        2:   58:            break;
        -:   59:        }
        -:   60:     }        
        2:   61:  return 0x12;
        -:   62:        
        -:   63:}
